### 题目 1

#### 内容

```javascript
function Foo() { // 函数 1
    getName = function () {
        console.log(1);
    }
    return this;
}
Foo.getName = function () { // 函数 2
    console.log(2);
}
Foo.prototype.getName = function () { // 函数 3
    console.log(3);
}
var getName = function () { // 函数 4
    console.log(4);
}
function getName() { // 函数 5
    console.log(5);
}

Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();

```

#### 答案

`2 4 1 1 2 3 3`

#### 解析

- `Foo.getName()`：直接调用**函数 2** ，故**打印 2**。
- `getName()`：调用的是**函数 4**。这里有 *getName* 的函数声明和函数定义：首先，**函数声明比变量声明优先级高**，故**函数声明**会整个提升到程度顶部；接着，**函数定义**会重写这个函数，故执行 *getName* 函数的时候，函数已经编程**函数 4**，故**打印 4**。
- `Foo().getName()`：先执行函数 *Foo()*，此时 *this* 指向 *window*，函数内部的 *getName* 代码相当于对全局的 *getName* 进行了重新赋值，故执行完 *Foo()* 后相当于 *this.getName()* 也就是 *window.getName()* 也就是 *getName()*，故**打印 1**。
- `getName()`：同上，此时全局的 *getName()* 已被重写，故**打印 1**。
- `new Foo.getName()`：*new* 实例化一个对象，也就是实例化 *Foo.getName* 对象，故**打印 2**。
- `new Foo().getName()`：相当于 `(new Foo()).getName()`，先实例化 *Foo* 对象，然后执行 *getName* 函数，*Foo* 并没有 *this.getName*，向原型链上查找，执行**函数 3**，故**打印 3**。
- `new new Foo().getName()`：相当于`(new (new Foo()).getName())`，先实例化 *Foo* 对象，然后实例化 *Foo* 原型上的 *getName* 函数，即**函数 3**，故**打印 3**。

#### 改题

改一下，如果把**函数 1** 改成：（其他不变）

```javascript
function Foo() { // 函数 1
    getName = function () {
        console.log(1);
    }
    return this;
}
```

那么答案则是：`2 4 1 1 2 1 1 `

解析：执行语句 1 2 4 5 不变，还是一样的逻辑，

- `Foo().getName()`：先执行函数 *Foo*，此时函数内部的 *this* 指向 *window*，*this.getName = ...* 相当于给全局的 *getName* 重新赋值了；故执行完 *Foo()* 后相当于 *this.getName()* 也就是 *window.getName()* 也就是 *getName()*，故**打印 1**。
- `new Foo().getName()`：相当于 `(new Foo()).getName()`，先实例化 *Foo* 对象，然后执行 *getName* 函数，此时*this* 指向 实例化对象， 构造函数有 *this.getName* 定义，不需要向原型链上查找，执行**函数 1** 内部的 *getName*，故**打印 1**。
- `new new Foo().getName()`：相当于`(new (new Foo()).getName())`，先实例化 *Foo* 对象，然后执行 *getName* 函数，此时 *this* 指向实例化对象， 构造函数有 *this.getName* 定义，不需要向原型链上查找，即**函数 1**内部的 *getName*，故**打印 1**。

### 题目 2

#### 内容

```javascript
function test(arg){
    // 1. 形参 arg 是 "hi"
    // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function
    console.log(arg);  
    var arg = 'hello'; // 3.var arg 变量声明被忽略， arg = 'hello'被执行
    function arg(){
		console.log('hello world') 
    }
    console.log(arg);  
}
test('hi');
```

#### 答案

```javascript
ƒ arg() {
    console.log('hello world')
}
hello
```

#### 解析

- 函数声明比变量声明优先级高，*arg* 函数定义整个被提升到程序顶部，故打印整个声明函数。
- `var arg = 'hello'`，*var arg* 变量声明被忽略， *arg = 'hello'* 被执行。

### 题目 3

#### 内容

```javascript
const a = {};
const b = { key: "b"};
const c = { key: "c"};
a[b] = 123;
a[c] = 456;
console.log(a[b]);
```

#### 答案

`456`

#### 解析

- 将对象作为对象的 *key* ,实际上是将 *[object Object]* 作为对象的 *key*。
- `a[b] = 123` 相当于 `a['[object Object]'] = 123`。
- `a[c]=456` 相当于 `a['[object Object]'] = 456`。
- 故**打印 456**；

#### 拓展

如果是数组作为对象的 *key*，则有以下规则：

- 数组单元是**对象类型**，将该对象变成 *[object Object]*。
- 数组单元是 **null** 和 **undefined**，删除。
- 其他类型：转化为字符串。

如：

```javascript
const a = {};
const b = [{
    a: 1
}, function () { console.log(123); }, null, undefined];
const c = [4, 5, 6];
a[b] = 111;
a[c] = 222;
console.log(a);
```

答案

`{"[object Object],function () {console.log(123);},,": 111, 4,5,6: 222}`

